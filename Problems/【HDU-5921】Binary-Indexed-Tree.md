[题目链接](http://acm.split.hdu.edu.cn/showproblem.php?pid=5921)
## 题目大意
对于树状数组这个数据结构，修改一个位置的值的代码如下
```cpp
void add (int x, int t ){
    for (int i = x; i != 0; i -= i & (-i))
        a[i] += t;
}
```
对于一次修改，会更改树状数组多个结点的值。
定义一种操作 $q(l, r), l \leq r$ 为 $add(r, t)$ 和 $add(l-1, -t)$ ，这时树状数组的一些结点的值被修改了，这种操作的权值就是被修改的结点数，注意如果结点 $i$ 在 $add(r,t)$ 中加了 $t$，而在 $add(l-1,t)$ 中减了 $t$，那么这个结点相当于没有被修改。

题目求对于 $[1,n]$ 这个树状数组中，所有的操作的权值和是多少？

## 分析
**记号**
$A = XXXX_{(2)}$ 表示一个数
$AB$ 表示在数位上将 $A$ 和 $B$ 拼接起来。
在 bit 中，一个 $x$ 的前缀和表示区间 $[1,x]$的数的和，一个前缀和在bit中由多个结点的和表示，比如 $111_{(2)}$ 的前缀和就由橙色的结点表示，而 $10010_{(2)}$ 由灰色的结点表示。其中，有 $x$ 的数位中多少个 $1$，则有多少个结点。

设一个操作的 $l - 1$ 用橙色表示， $r$ 用灰色表示，有上图中，$l - 1 = 111_{(2)}$ 而 $r = 10010_{(2)}$ ，显然这时，修改的个数 $3 + 2$，发现 $i \lt 10000_{(2)}$ 的修改都不会影响 $r$ 的修改，而 $i = 10001_{(2)}$ 的修改会使 $r$ 的修改减少 $1$，即 $10000_{(2)}$ 这个结点。

$10010_{(2)}$ 在bit中由两个结点表示，分别为 $10000_{(2)}$ 和 $10010_{(2)}$，当 $r$ 是 $10010_{(2)}$ 时，只要 $l - 1 < 10010_{(2)}$ 就不会影响对于结点 $10010_{(2)}$ 的修改，同样，对于只要 $l - 1 < 10000_{(2)}$ 那么就不会影响到 $10000_{(2)}$ 结点的修改。再考虑 $l - 1$ 自身对于bit的修改。当 $l - 1 = 10001_{2}$ 时，发现其等价于 $l - 1 = 1$ 的情况，原因在于其多的部分被抵消了。这样，对于固定的位来说，这一部分的贡献是化归成子问题的。

回到问题，题目要求所有的操作的权值和，令答案为 $f(n)$。
考虑固定右端点，所有操作右端点是 $i$ 的权值和为 $g(n)$ ，有 $f(n) = \sum g(i)$ 。

根据以上的分析，$g(i)$ 的值分为两部分，一部分是
```cpp
int first(int x) {
    int ret = 0;
    while (x) {
        ret += x; // l - 1 < x, l - 1 的数量为 x
        x -= x & -x; //　这样就计算了 x 的所有的结点的贡献
    }
    return ret;
}
```
还有一部分可以转化为是当 $r = 1 << k$ 时，$l - 1 < r$ 时，所有的操作的权值是多少，可以列一个表出来
0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8
- | - | - | -- | -- | -- | --- | --- | ----
- 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256
- 0 | 1 | 4 | 12 | 32 | 80 | 192 | 448 | 1024
当 $k$ 是$2$ 时，这时 $r$ 代表的结点是 $100_{(2)}$ ，$l - 1$ 显然有 $0, 1, 2, 3$ 这几种选择，$0 \to 0, 1 \to 1, 2 \to 1, 3 \to 2$，这时和为 $4$。可以通过递推式将通项公式算出来，为 $k 2^{k-1}$ 这样，第二部分的权值为
```cpp
int second(int x) { int ret = 0; for (int i = 0; x; i++, x>> 1) {
        if (x & 1) ret += i * pow_mod(2, i-1); //当 i - 1小于 0 时，pow_mod返回的结果是 0
    }
    return ret;
}
```

现在要解决的问题是，如何在n最大 $1e18$ 的情况下，求出 $\sum g(i)$。

发现不管是第一部分还是第二部分，对于答案的贡献都是一些 $2^i$ 的累加，如果枚举 $i$，求出有多少个 $2^i$ 的贡献，就可以算出答案了。

以 $r = 1001010_{(2)}$ 为例，它的第一部分的贡献为 $1000000_{(2)} + 1001000_{(2)} + 1001010_{(2)}$，发现 $1000000_{(2)}$ 计算了 $3$ 次，$1000_{(2)}$ 计算了 $2$ 次，如果考虑一般的例子，$2^i$ 的系数为 $0$，如果 $r$ 的第 $i$ 位为 $0$，否则就为小于等于 $i$ 的位上 $1$ 的个数。考虑第二部分，贡献为 $1 \cdot 2^0 + 3 \cdot 2^2 + 6 \cdot 2^5$。

因为，对于一个 $n$ 来说，考虑每一位，当考虑第 $i$ 位时，令这一位为 $1$，可以用数位dp类似的思考方式算出有多少个这样的数，这一位是 $1$，那么就可以直接算出第二部分的贡献出来，至于第一部分，贡献取决于小于等于第 $i$ 的 $1$ 的个数，也就是取决于所有这些数中小于等于第$i$位的数位的$1$的总和，要算出这部分出来，还需要考虑三个种情况，一个是如果小于第$i$位的值($0/1$)可以任意取（在第 $i$ 的前缀部分小于 $n$ 第 $i$ 位的前缀部分时，此时任意取后值是不会大于 $n$的），这时要求的就是 $\sum jC_i^j[0 \leq j \leq i] = \sum iC_{i-1}^j[0 \leq j \leq i-1] = i 2^{i-1}$，如果不能任意取（在第 $i$ 的前缀部分等于 $n$ 第 $i$ 位的前缀部分时），令这一部分的值为 $w[i]$，可以通过 DP 转移来求，考虑第 $i$ 位，如果这个位上的值是 $0$，那么$w[i+1] = w[i]$，因为没有影响，如果这一位是 $1$，那么令这一位是 $0$，小于这一位的数就可以任取，为$i2^{i-1}$而，如果令这一位是 $1$的话，对于前一个状态的每一个数，相当于多了一个 $1$，所以是 $w[i] + num$，$num$ 表示前一个状态所有数，且 $num = n \& ((1<<i) - 1) + 1$，第三种情况就是第 $i$ 位自身，因为前两部分算出来的就小于 第 $i$位的 $1$ 的个数，这一部分直接就是这一位是 $1$ 的数的个数。 要注意的是第一部分算出来是 $2^i$ 的系数，而第二部分处出来的是 $2^{i-1}$ 的系数。 这样，就可以通过考虑第一位的贡献求出答案来了。 ## 代码实现

```cpp
# include <bits/stdc++.h>

using namespace std;
# define cmin(x,y) ((x)=min(x,y))
# define cmax(x,y) ((x)=max(x,y))
# define sq(x) ((x)*(x))
# define x first
# define y second
# define orz(x) cerr<<#x<<" = "<<x<<endl typedef pair<int, int> Pr;
typedef double DB;
typedef long long LL;
const int N = 100;
const int MOD = 1e9 + 7;

int a[N];
LL n, m;

LL pow_mod(LL a, LL n) {
    if (n < 0) return 0;

    LL ret = 1;
    while (n) {
        if (n & 1) ret = (ret * a) % MOD;
        a = (a * a) % MOD;
        n >>= 1;
    }
    return ret;
}

LL w[N];

int main(void) {
#ifdef owly
    freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
#endif // owly

    int T, cnt = 1;
    scanf("%d", &T);
    while (T --) {
        scanf("%lld", &n);
        LL cp = n;
        m = 0;
        while (cp) {
            a[m] = cp % 2;
            cp /= 2, m ++;
        }

        for (LL i = 0, mask = 1; i < m; i++, mask <<= 1) { // orz(mask);
        if (a[i] == 1)
            w[i + 1] = (i * pow_mod(2, i - 1) % MOD + w[i] + (n % mask) % MOD + 1) % MOD;
        else
            w[i + 1] = w[i];
            // printf("%lld%c", w[i + 1], " \n"[i==m-1]);
        }
        LL ans = 0;
        for (LL i = 0, mask = 1; i < m; i++, mask <<= 1) {
            LL num = (((n / mask)>> 1) % MOD * pow_mod(2, i)) % MOD;
            if (a[i] == 1) num = (num + (n % mask) % MOD + 1) % MOD;

//            orz(mask);
//            orz(num);

            ans = (ans + (num * i) % MOD * pow_mod(2, i - 1)) % MOD;

            LL extra = ((n / mask) >> 1) % MOD * ((i * pow_mod(2, i - 1)) % MOD) % MOD;
            extra = (extra + num) % MOD;
            if (a[i] == 1) extra = (extra + w[i]) % MOD;

            ans = (ans + extra * pow_mod(2, i) % MOD) % MOD;
        }
        printf("Case #%d: %lld\n", cnt ++, ans);
    }



    return 0;
}
```
