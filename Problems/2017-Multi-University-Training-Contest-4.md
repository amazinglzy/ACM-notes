# Summary
## 1002 Classic Quotation
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6068)
**题目大意**
给定一个模板串，还有一个子串，给定$L, R$，对于 $\{(l,r) | 1 \leq l \leq L, R \leq r \leq n \}$ ，求删除 $(l,r)$的开区间后剩下的模板串能够匹配子串的次数和。

**限制条件**
$1 \leq n \leq 50000$
$1 \leq m \leq 100$
$1 \leq k \leq 50000$

**思路**
对于一个$(l, r)$，删除这个开区间后剩下的模板串能够匹配子串的次数包括 **前面**的部分能够匹配的次数 和 **后面**的部分能够匹配的次数 以及 这个串能够**横跨**这两部分的次数。
前面的部分好算，对于后面的两个部分，假设前面的部分模板串和后面的部分是连接起来的，显然对其跑一遍KMP就可以得到答案，假设现已处理完前一部分，前一部分将当前子串的匹配状态$[1..j]$ 传到后面，在此基础上继续跑KMP，所以需要将这个值用 $pref[i]$ 存起来，$pref[i] = j$ 表示前缀 $i$ 的跑完 KMP 后子串当前$[1..j-1]$完成匹配，接下来比较 $j$ 这个位置，后面的部分用 $suf[i][j]$ 表示 后缀 $i$ 用子串从 $j$ 位置开始比较，能够完成的匹配次数，再用 $preg[i]$ 表示前缀 $i$ 能够完成子串匹配的次数。

$g[j][s[i]]$ 和 $c[j][s[i]]$ 分别是KMP的中间数组，分别表示当前子串练匹配状态为 $[1..j]$ 时下一个匹配字符是 $s[i]$ 时，子串将要变化的匹配状态，而 $c[j][s[i]]$ 为 $1$ 表示当前子串的匹配状态为 $[1..j]$ 时下一个匹配字符是 $s[i]$ 时完成子串的整个的匹配。

对于 $suf[i][j]$，$suf[i][j] = suf[i+1][g[j][s[i]]] + c[j][s[i]]$
对于后缀 $i$，假如在读入 $s[i]$ 后，完成匹配，则对于 $suf[i][j]$ 贡献加 $1$，这就相当于加上 $c[j][s[i]]$，在读入 $s[i]$ 后，子串匹配状态由 $[1..j]$ 变为 $[1..g[j][s[i]]$，即由 $suf[i+1][g[j][s[i]]]$ 转移过来，对于 $suf[i][j]$ 加上 $suf[i+1][g[j][s[i]]]$ 的贡献。

这样对于 $(l, r)$，次数就是 $pred[l] + suf[r][pref[l]]$
所以答案是

$$
\sum_{l = 0}^{L} \sum_{r = R}^{n-1} pred[l] + suf[r][pref[l]]
= (n - 1 - R + 1) \sum_{l=0}^{L} pred[l]+ \sum_{l = 0}^{L} \sum_{r = R}^{n-1} suf[r][pref[l]]
$$

因为 $pref[l]$ 的取值为 $[1..m]$，所以可以考虑 $pre[l] = i$ 时的贡献。首先，需要知道产生子串状态为 $i$ 的 $(l,r)$ 的对数 $a$，贡献是$a \cdot \sum_{r = R}^{n-1}suf[r][i] $
对于$a$, 用$sum[i][j]$ 表示$[1..i]$的$i$个前缀中，产生子串状态为$j$的数，在KMP计算的时候预处理出来，这样就就可以算出答案来了。

----------

## 1004 Dirt Ratio
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6070)

**题目大意**
大小为 $n$ 整数数组，求一个区间 $[l,r]$ 内不同的数的个数 $num$ 使得 $\frac {num} {r - l + 1}$ 最小
**限制条件**
$1 \leq n \leq 6000$
$1 \leq a_i \leq n$
**思路**
二分答案，对于二分的 $mid$，找是否有一个区间的值小于 $mid$，即

$$ \frac {num(l,r)} { r - l + q} \leq mid $$

与就是求一个区间满足

$$ num(l, r) + mid \cdot l \leq mid \cdot (r + 1)$$

这样，枚举 $r$ 的取值，就可以用一个线段树维护 $l=[1..r]$ 时 $num(l,r) + mid \cdot l$ 最小值，而每当 $r$ 加 $1$ 时，对于线段树的修改是对于$r+1$ 这个位置上的数以及左边离这个数最近的与这个数相同的数之间的这些位置上加 $1$，因为以这些位置到$r+1$的这些区间都新加了一个之前没有的数。

这样，每加一个数，查询左边最小值是否小于右边，如果小于说明答案比 $mid$ 大

这样二分下去就可以求出来了。

----------

## 1005 Lazy Running
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6071)

**题目大意**
在一个四条边的环上，从 $2$ 号结点出发，问回到 $2$ 号结点的大于 $K$ 的最小路径是多少。

**限制条件**
$1 \leq K \leq 10^{18}$
$1 \leq d_i \leq 30000$

**思路**
对于一条路径，考虑先循环 $2\to1\to2\to1\to \cdots$ 或类似的方法走，假设一次循环走 $2w$ 的长度，那么走 $d + k\cdot 2w $的路径都是合法的，那么只用求出模 $2w$ 为 $j$ 的到起始点的最小路径长度，跟 $K$ 比较之后对答案更新就好了。

对于任意的 $2w$，都可以算出正确答案的，所以取最小值 $min(d_0, d_1)$

----------


## 1009 Matching In Multiplication
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6073)

**题目大意**
给定 $2n$ 个点，前 $n$ 个点每个点有 $2$ 条边，每条边的另一个端点是另外的 $n$ 个点，定义一个完美匹配的值是所有匹配的边的乘积，而一个图的值是一个图所有的匹配的值的和，求出这个图的值。
**限制条件**
$1 \leq n \leq 300000$

**思路**
对于度数为 $1$ 的点，连到这个点的边以及点是唯一确定的。
找度数为 $1$ 点，删除这个点以及与这个点相连的点，对图更新后，循环操作，直到不能操作为止。

对于剩下的图，标点为前$n$的点有两条边，其它的点连的边数大于$1$，这两部分的点相等，所以所有的点的度数都是 $2$，顺着一个点走，总能找到一个环，对于一个环，有两种匹配方式，设有$m$个环，$p_i$ 和 $q_i$ 表示第$i$个环两种匹配的值，那么答案就是
$$a \prod_{i=1}^m (p_i + q_i)$$
$a$ 是固定的匹配的值。

----------

## 1012 Wavel Sequence
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6078)

**题目大意**
给定长度为 $n$ 的 $a_i$ 的数组，$m$ 的 $b_i$ 的数组，求公共子序列 $s_i$ 满足 $s_1 > s_2 < s_3 > s_4 < \cdots $的数目。

**限制条件**
$1 \leq n, m \leq 2000$
$1 \leq a_i \leq 2000$
$1 \leq b_i \leq 2000$

**思路**
用 $dp[i][j][k]$ 表示 $a[i] = b[j]$ 且以 $a[i]$ 作为结尾且 $a[i]$ 的状态是波峰 $1$ 或波谷 $0$ 的方案数，那么$dp[i][j][k] = \sum dp[x][y][1-k]\ (x < i, y < j)$，且当$k = 1$时，$a[x] < a[i]$，当$k = 0$时，相反

可以用两个数组将一个矩形的贡献压到一个点上，$h[i][j][k]$ 表示由当前状态是 $k$ 的数 $a[i]$ 下一个位置将要是 $a[j]$ 的方案数，而 $v[i][j][k]$ 是当前状态 $k$ 的数是 $a[j]$ 并前一个数 $a[i]$ 的方案数。

转移为
$dp[i][j][k] = v[i - 1][j][k] + 1$
$h[i][j][k] = h[i][j-1][k] + dp[i-1][j][k]$
$v[i][j][k] = v[i-1][j][k] + h[i][j][1-k] (a[i] \neq b[j])$
