# Summary
## 1003 Colorful Tree
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6035)

**题目大意**
给定一个 $n$ 个结点的树。
每个结点上有一个 $c_i$ 的颜色。
定义连接树上两个结点的路径的值为路径上的不同颜色的结点的个数。
求树上 $\frac {n(n - 1)} {2}$ 条路的值的和。

**限制条件**
$n \leq 2 \times 10^5$
$c_i \leq n$

**思路**
转化为 求每种结点对答案的贡献，即对于每种结点，算出有多少条路径包含该种结点。
求出不包含该结点的路径的条数后用总条数减去就可以求上述的路径数。
考虑某相同颜色结点，它们将树分成了几块，每一块都是一棵不包含该颜色结点的树，这些树的总的路径条数就是不包含这种颜色结点的路径条数。
考虑某一块，树上与这一块相连的结点都是相同的颜色的结点，通过处理与该块相连的深度最小的结点来处理该块对路径条数的贡献。
设一个块被以颜色为 $c_i$ 的结点分隔，一般情形下，一个块的大小为一个以颜色为 $c_i$ 的结点为根$v$的子树的总结点数 减去 这棵树子孙结点以颜色为 $c_i$。 的结点$u$为根的子树的结点数，并且这棵树的根结点 $u$ 到结点 $v$ 的路径上没有颜色为 $c_i$ 的结点。
具体来说，$pre[c]$ 表示距当前结点最近的颜色为$c$ 的祖先结点，$last[c]$ 表示当前颜色为 $c$ 的结点（且该结点到根的路径上没有颜色为 $c$ 的结点 ）对应的子树的结点数，$cur[v]$ 表示以结点 $v$ 为根的子树上上述减去的部分，一遍搜索就可以求出来了。

----------


## 1010 Journey with Knapsack
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6042)


**题目大意**
对于 $n$ 个物品，第$i$个体积为 $i$，个数为$a_i$，还有 $m$ 个体积为 $b_i$ 的物品，这些物品放到一个容量为$2n$的背包里，$m$ 个物品必须放一个且只能放一个，问有多少种不同的方案可以放满背包。

**限制条件**
$ 1 \leq n \leq 5e4$
$ 1 \leq m \leq 2n$
$ 0 \leq a_1 \lt a_2 \lt \cdots \lt a_n \leq 2n$
$ 0 \leq b_0, b_1, b_2, \cdots, b_n \leq 2n$

**思路**
生成函数$F(x) = \sum f(i) x^i$
$f(i)$ 表示这些物品占用背包体积为 $i$ 的方案数。
$$F(x) = (1 + x^1 + x^2 + \cdots + x^{a_1}) \cdot (1 + x^2 + x^4 + \cdots + x^{2a_2}) \cdots  $$

$$F(x) = \prod_{i=1}^{n} \frac {1 - x^{(a_i + 1)i}} {1 - x^{i}} = \prod_{i=1}^{n} {(1 - x^{(a_i + 1)i})} \prod_{i=1}^{n} \frac {1} {1 - x^{i}} $$

因为$ 0 \leq a_1 \lt a_2 \lt \cdots \lt a_n \leq 2n$，所以$a_i + 1 > i$，所以 $(a_i + 1)i > i^2$，所以有共有$O(\sqrt n)$个$i$使${(1 - x^{(a_i + 1)i})}$在模$x^{2n+1}$下的有值，所以可以先求出后面的项后用动态规划来求最后的答案。

而后面的项可以借助整数的拆分数来求。
在模$x^{2n+1}$下
$$\prod_{i=1}^{2n} \frac {1} {1 - x^i} = \sum_{i = 0}^{2n}P(x)x^i$$

$P(x)$就整数$x$的分拆数

> $$ \prod_{i=1}^{\infty} (1 - x^i) = \sum_{i = 0}^{\infty} x^{\frac {i(3i-1)} {2} + \frac {i(3i+1)} {2}}$$
>
>$$ \prod_{i=1}^{\infty} (1-x^i) \sum_{i=0}^{\infty}P(i)x^i = 1 $$

可以通过上述关系推出递推关系，求出$P(x)$

$$\prod_{i=1}^n (1 - x^i) = \prod_{i=n+1}^{2n} (1-x^i) \prod_{i=1}^{2n} \frac {1} {1 - x^i} = (1 - \sum_{i=n+1}^{2n}x^i) \sum_{i=0}^{2n}P(i)x^i$$

维护$P(i)$ 的前缀和，可以用$O(n)$的方法求出上述的生成函数的每一项的系数，具体来说，对于$x^i$的系数，它包括$P(i)$ 乘$1$，和$\sum_{k=n+1}^{2n} -p(i - k)$，如果$i-k \lt 0$，那么$P(i-k) = 0$

回到上面，用动态规划的方法把前面的项规约到这个生成函数里面来就得出答案了。

----------


## 1012 Limited Permutation
[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6044)


**题目大意**
给定 $n$ 个 $l_i, r_i$
有排列$p_i$满足对于每一个 $i$, 排列中 $[l_i, r_i]$区间内的所有元素的最小值是 $p_i$
$[l_i, r_i]$满足上述情况下长度最大的，即如果存在 $j = l_i - 1, i \geq 0$, 一定有 $p_j < p_i$
求这样的排列的个数。

**限制条件**
$n \leq 10^6$

**思路**
对于长度为 $n$ 的一个排列，考虑它的 $1$ 的区间
$[l_1, r_1]$ 一定是 $[0, n - 1]$, 且 $1$ 将这个区间分成了两个部分，因为排列的其它元素的区间 $[l_i, r_i]$ 中一定不会出现 1 这个元素。
这样相当于划分成两个子问题，
即用一些区间来覆盖区间 $[l, r]$，一定会有一个区间$[l_i, r_i]$满足$l_i = l, r_i = r$，因为与这个区间相关的数 $i$ 是这些区间相关数的最小值，
然后将剩下的区间来覆盖 $[l, p_i - 1]$ 和 $[p_i + 1, r]$
将直接覆盖的区间之间建立一条边，这样就形成了一颗树。

这是一颗笛卡尔树

如果建立成功，接下来就是要求如何求：
每次删除这颗树的一个叶结点，有多少方案数可以删完这颗树。

用$ans[v]$表示删除根结点为$v$的子树的方案数。
$ans[v] = \prod_u ans[u] C_{\sum_{the\ rest\ u}sz[u]}^{sz[u]}$
$u$ 表示 $v$ 的儿子结点。
$sz[u]$ 标志以$u$ 为根结点的子树的结点数。
$the\ rest\ u$ 是在依次考虑结点 $v$ 的孩子的过程中，还剩下的没有考虑的孩子结点的集合。

**需要注意的是**
1. 可能无法建成一棵树，此时答案是0
2. 各个区间不能相交，只能相离或包含或被包含
3. 每个结点有 $0$ 或 $1$ 或 $2$ 个儿子
4. 结点表示的区间长度 减去 儿子们的表示的长度的值为$1$
5. 这棵树有 $n$ 个结点
6. 用 $O(n)$ 的复杂度建树，参考笛卡尔树的建树方法
7. 读入数据需要用输入挂
